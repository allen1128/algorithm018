学习笔记

预习：
训练：拆分知识点，练习，反馈
五毒神✋：1，看懂背诵前3种答案和复杂度分析，2， 默写， 3, 第2天复习, 4. 下周复习。 5， 面试前一周
误区：死杠和只做一遍
时间复杂度：O(1) 常数， O(logN) 对数 比如搜索， O（N）线性时间复杂度比如遍历， O（NLogN）排序， O(N^2) 平方，双层遍历， O(N^3) 立方比如三层遍历， O(2^N)指数， O(N!)阶乘
主定理可以计算所以的递归函数：二分查找O(LogN)， 二叉树的遍历O(N)，排好序的二维矩阵 O(N), 合并排序 O（NLogN)

第一周：
1. 
数组：相邻的元素地址在内存中也相邻，从而可以直接访问。因此访问的时间复杂度是常数，而为了保持这种特性，插入和删除需要挪动元素，时间复杂度是O(N)。
链表：元素有VALUE和NEXT的字段，NEXT指向下一个元素，因为相邻元素在内存中不必相邻，插入和删除不需要挪动元素，时间复杂度是O(1)，而访问为O(n).
跳表：链表的访问时间复杂度为O(N). 而提高算法性能的主要做法为空间换时间而提高一维数据结构的性能是转为二维。这里跳表为二维的数据结构。
它将一维数据的某些节点作为二维节点，从而跳过一些节点提高访问效率。跳表的时间复杂度为O(LogN), 但是为了维护数据结构，插入和删除的数据结构也是O(LogN).

2。 
栈：先进后出，插入和删除复杂度是O(1)，而访问为O(N)
队列：先进先出，插入和删除复杂度是O(1)，而访问为O(N)
双端队列：栈和队列的结合体，插入和删除复杂度是O(1)，而访问为O(N)
优先队列：插入O(1)，取出复杂度是O(LogN)，而访问还是O(N)




  
  
 